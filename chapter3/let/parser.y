%require "3.2.2"
%language "c++"
%debug

%defines
%define parse.assert
%define api.value.type variant
%locations

%code requires // *.h
{
#include <vector>
#include <string>

namespace yy {
  class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
  using Value = std::vector<std::string>;
}

}

// Construct parser object with lexer and result
%parse-param {yy::Lexer& lexer}{Value& result}

%code // *.cpp
{

#include <boost/lexical_cast.hpp>

#include "lex.yy.h"
#undef yylex
#define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

// customize the error behavior
void yy::parser::error(const parser::location_type& l, const std::string& m) {
  throw parser::syntax_error(l, m);
}

}

%token <int>          INT           "integer"
%token <std::string>  STRING        "string"
%token                QUOTE         "quote"
%token                END_OF_FILE   "end of file"

%type <std::string> item
%type <std::vector<std::string>> list nlist

%%
result  : list { result = std::move($1); }
        ;

list  : %empty { $$ = std::vector<std::string>(); }
      | nlist { $$ = std::move($1); }
      ;

nlist : item   { $$ = std::vector<std::string>{std::move($1)}; }
      | nlist ',' item { $1.push_back($3); $$ = std::move($1); }
      ;

item  : STRING { $$ = std::move($1); }
      | INT { $$ = boost::lexical_cast<std::string>($1); }
      ;
%%
