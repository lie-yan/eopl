%require "3.2.2"
%language "c++"
%debug

%defines
%define parse.assert
%define api.value.type variant
%locations

%code requires // *.h
{
#include "expr.h"
#include "type/type.h"

namespace yy {
  class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
  using Result = eopl::Program;
}

}

// Construct parser object with lexer and result
%parse-param {yy::Lexer& lexer}{Result& result}

%code // *.cpp
{

#include "lex.yy.h"
#undef yylex
#define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

// customize the error behavior
void yy::parser::error(const parser::location_type& l, const std::string& m) {
  throw parser::syntax_error(l, m);
}

using eopl::ConstExp, eopl::VarExp, eopl::IfExp, eopl::LetExp, eopl::UnpackExp;
using eopl::CondExp, eopl::ProcExp, eopl::CallExp, eopl::LetrecExp, eopl::Program;
using eopl::PairExp, eopl::UnpairExp;
using eopl::type::BoolType, eopl::type::IntType, eopl::type::ProcType, eopl::type::PairType;
using eopl::LetrecProc;
using eopl::to_exp;

}

%token <eopl::Int>    INT           "integer"
%token <eopl::Symbol> IDENTIFIER    "identifier"
%token                IF            "if"
%token                THEN          "then"
%token                ELSE          "else"
%token                LET           "let"
%token                LET_STAR      "let*"
%token                LETREC        "letrec"
%token                UNPACK        "unpack"
%token                IN            "in"
%token                COND          "cond"
%token                RIGHT_ARROW   "==>"
%token                END           "end"
%token                PROC          "proc"
%token                END_OF_FILE   "end of file"
%token                BOOL_TYPE     "bool"
%token                INT_TYPE      "int"
%token                MAPS_TO       "->"
%token                PAIR_OF       "pairof"
%token                NEW_PAIR      "newpair"
%token                UNPAIR        "unpair"

%type <eopl::Expression> expression
%type <std::vector<eopl::Expression>> exp_nlist
%type <eopl::CondExp::ClauseList> cond_clause_list
%type <eopl::CondExp::Clause> cond_clause
%type <eopl::LetExp::ClauseList> let_clause_list
%type <eopl::LetExp::Clause> let_clause
%type <bool> let_variant
%type <std::vector<eopl::Symbol>> id_list
%type <std::vector<eopl::ParamDecl>> param_list_comma
%type <eopl::LetrecProc> proc_spec
%type <std::vector<eopl::LetrecProc>> proc_spec_nlist
%type <eopl::type::Type> type
%type <std::vector<eopl::type::Type>> type_nlist_comma
%type <eopl::ParamDecl> param_decl
%%

program : expression { result = Program{std::move($1)}; }
        ;

expression  : INT      { $$ = to_exp(ConstExp{$1}); }
            | IDENTIFIER { $$ = to_exp(VarExp{$1}); }
            | IF expression THEN expression ELSE expression
              { $$ = to_exp(IfExp{std::move($2), std::move($4), std::move($6)}); }
            | COND cond_clause_list END
              { $$ = to_exp(CondExp{std::move($2)}); }
            | let_variant let_clause_list IN expression
              { $$ = to_exp(LetExp{std::move($2), std::move($4), $1}); }
            | UNPACK id_list '=' expression IN expression
              { $$ = to_exp(UnpackExp{std::move($2), std::move($4), std::move($6)}); }
            | PROC '(' param_list_comma ')' expression
              { $$ = to_exp(ProcExp{std::move($3), std::move($5)}); }
            | '(' expression exp_nlist ')'
              { $$ = to_exp(CallExp{std::move($2), std::move($3)}); }
            | LETREC proc_spec_nlist IN expression
              { $$ = to_exp(LetrecExp{std::move($2), std::move($4)}); }
            | NEW_PAIR '(' expression ',' expression ')'
              { $$ = to_exp(PairExp{std::move($3), std::move($5)}); }
            | UNPAIR IDENTIFIER IDENTIFIER '=' expression IN expression
              { $$ = to_exp(UnpairExp{{std::move($2),std::move($3)}, std::move($5), std::move($7)}); }
            ;

type : BOOL_TYPE { $$ = to_type(BoolType()); }
     | INT_TYPE { $$ = to_type(IntType()); }
     | '(' type_nlist_comma MAPS_TO type ')'
       { $$ = to_type(ProcType{std::move($2), std::move($4)}); }
     | PAIR_OF type '*' type
       { $$ = to_type(PairType{std::move($2), std::move($4)});}
     ;

type_nlist_comma : type { $$ = std::vector<eopl::type::Type>{std::move($1)}; }
                 | type_nlist_comma ',' type { $1.push_back(std::move($3)); $$ = std::move($1); }
                 ;

exp_nlist : expression  { $$ = {std::move($1)}; }
          | exp_nlist expression { $1.push_back(std::move($2)); $$ = std::move($1); }
          ;

param_list_comma : %empty { $$ = std::vector<eopl::ParamDecl>(); }
                 | param_decl { $$ = std::vector<eopl::ParamDecl>{std::move($1)}; }
                 | param_list_comma ',' param_decl { $1.push_back(std::move($3)); $$ = std::move($1); }
                 ;

param_decl : IDENTIFIER ':' type
             { $$ = eopl::ParamDecl{std::move($1), std::move($3)}; }
           ;

cond_clause_list : %empty { $$ = eopl::CondExp::ClauseList(); }
                 | cond_clause_list cond_clause { $1.push_back(std::move($2)); $$ = std::move($1); }
                 ;

cond_clause : expression RIGHT_ARROW expression
              { $$ = eopl::CondExp::Clause{std::move($1), std::move($3)}; }
            ;

let_clause_list : %empty { $$ = eopl::LetExp::ClauseList(); }
                | let_clause_list let_clause { $1.push_back(std::move($2)); $$ = std::move($1); }
                ;

let_clause : IDENTIFIER '=' expression
             { $$ = eopl::LetExp::Clause{std::move($1), std::move($3)}; }
           ;

let_variant : LET { $$ = false; }
            | LET_STAR { $$ = true; }
            ;

proc_spec_nlist : proc_spec { $$ = std::vector<eopl::LetrecProc>{std::move($1)}; }
               | proc_spec_nlist proc_spec { $1.push_back(std::move($2)); $$ = std::move($1); }
               ;

proc_spec : type IDENTIFIER '(' param_list_comma ')' '=' expression
           { $$ = LetrecProc{std::move($2), std::move($4), std::move($7), std::move($1)}; }
         ;

id_list : %empty { $$ = std::vector<eopl::Symbol>(); }
        | id_list IDENTIFIER { $1.push_back(std::move($2)); $$ = std::move($1); }
        ;



%%
